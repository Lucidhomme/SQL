SELECT *
FROM   EMPLOYEE ;

SELECT EMP_NAME, SALARY, NVL(BONUS_PCT,0)
FROM   EMPLOYEE
WHERE  SALARY > 3500000 ;

SELECT EMP_NAME,
       (SALARY*12)+((SALARY*12)*BONUS_PCT)
FROM   EMPLOYEE
WHERE  SALARY > 3500000 ;

SELECT EMP_NAME,
       (SALARY*12)+((SALARY*12)*NVL(BONUS_PCT,0))
FROM   EMPLOYEE
WHERE  SALARY > 3500000 ;

SELECT EMP_NAME,
       EMP_NO,
       SUBSTR(EMP_NO, -7, 1),
       DECODE(SUBSTR(EMP_NO, -7, 1),'1','남자','2','여자') AS GENDER,
       DECODE(SUBSTR(EMP_NO, -7, 1),'1','남자','3','남자','여자') AS GENDER2
FROM   EMPLOYEE
WHERE  DEPT_ID = '50' ;

SELECT *
FROM   EMPLOYEE 
WHERE  JOB_ID = 'J4' ;

SELECT EMP_NAME,
       DECODE(MGR_ID, NULL, '관리자','직원')
FROM   EMPLOYEE
WHERE  JOB_ID = 'J4' ;

SELECT EMP_NAME,
       MGR_ID,
       NVL2(MGR_ID, '직원', '관리자') AS 구분
FROM   EMPLOYEE
WHERE  JOB_ID = 'J4' ;


SELECT *
FROM   JOB ;

SELECT *
FROM   EMPLOYEE ;

--사원(j7) 20 대리(j6) 15 과장(j5) 10 프로 연봉인상

SELECT EMP_NAME,
       JOB_ID,
       SALARY,
       DECODE(JOB_ID,'J7',(SALARY*1.2),'J6',(SALARY*1.15),'J5',(SALARY*1.1)) AS 연봉인상적용결과
FROM   EMPLOYEE 
WHERE  JOB_ID = 'J5' OR JOB_ID = 'J6' OR JOB_ID = 'J7';

SELECT EMP_NAME,
       JOB_ID,
       SALARY,
       CASE JOB_ID WHEN 'J7' THEN (SALARY*1.2) 
                   WHEN 'J6' THEN (SALARY*1.15) 
                   WHEN 'J5' THEN (SALARY*1.1) ELSE SALARY 
       END AS 연봉인상적용결과
FROM   EMPLOYEE 
WHERE  JOB_ID = 'J5' OR JOB_ID = 'J6' OR JOB_ID = 'J7';

SELECT EMP_NAME,
       JOB_ID,
       SALARY,
       CASE WHEN JOB_ID = 'J7' THEN SALARY*1.2 
            WHEN JOB_ID = 'J6' THEN SALARY*1.15 
            WHEN JOB_ID = 'J5' THEN SALARY*1.1 ELSE SALARY 
            END AS 인상급여 
FROM   EMPLOYEE 
WHERE  JOB_ID = 'J5' OR JOB_ID = 'J6' OR JOB_ID = 'J7';


--사원테이블에서 급여를 기준으로 사원의 급여등급을 확인하고 싶다(급여가 3000000이하면 초급, 4000000이하면 중급, 4000000초과면 고급개발자)
SELECT *
FROM   EMPLOYEE ;

SELECT  EMP_NAME,
        JOB_ID,
        SALARY,
        CASE WHEN SALARY <= 3000000 THEN '초급개발자' 
             WHEN SALARY > 3000000 AND SALARY <= 4000000 THEN '중급개발자' 
             WHEN SALARY > 4000000 THEN '고급개발자' 
        END AS 급여등급
FROM    EMPLOYEE ;

--오더바이는 무조건 셀렉구문의 마지막에 나와야하고 디폴트는 어센딩,NULL값 마지막으로가는 NULLS LAST사용가능
SELECT EMP_NAME,
       SALARY
FROM   EMPLOYEE
WHERE  DEPT_ID = '50'
OR     DEPT_ID IS NULL
ORDER BY SALARY DESC ;

SELECT EMP_NAME,
       HIRE_DATE,
       DEPT_ID
FROM   EMPLOYEE
WHERE  HIRE_DATE > TO_DATE('20030101', 'YYYYMMDD')
ORDER BY DEPT_ID DESC NULLS LAST, HIRE_DATE, EMP_NAME ;

SELECT EMP_NAME AS 이름,
       HIRE_DATE AS 입사일,
       DEPT_ID AS 부서코드
FROM   EMPLOYEE
WHERE  HIRE_DATE > TO_DATE('20030101', 'YYYYMMDD')
ORDER BY 부서코드 DESC, 입사일, 이름 ;

SELECT EMP_NAME AS 이름,
       HIRE_DATE AS 입사일,
       DEPT_ID AS 부서코드
FROM   EMPLOYEE
WHERE  HIRE_DATE > TO_DATE('20030101', 'YYYYMMDD')
ORDER BY 3 DESC, 2,1 ;


--그룹함수를 사용하기위해 그룹이 이어져 있어야함.단독으로가 아닌 그룹바이 절과 사용

--집계함수(그룹바이)사용할때 SELECT절에 그룹함수를 쓰면 일반컬럼을 정의할 수 없다
--ex)SELECT DEPT_ID,
--          SUM(SALARY)
--    FROM  EMPLOYEE ;

--그룹바이를 사용하면 SELECT절에 사용가능하다
--SELECT DEPT_ID,
--SUM(SALARY)
--FROM   EMPLOYEE 
--GROUP BY DEPT_ID 
--ORDER BY 2 ;

--그룹바이절에 명시된 절은 셀렉절에 집계함수가 있어도 절로 정의될 수 있다
--(셀렉절에 여러개를 명시하기 위해서는 그룹바이에 전부넣어야함, 함수중첩사용할때는 그룹바이에 명시되어있어도 사용이 되지않음)
--ex) SELECT DEPT_ID
--           MAX(SUM(SALARY))
--    FROM  EMPLOYEE
--    GROUP BY DEPT_ID ;

SELECT DEPT_ID,
       SUM(SALARY)
FROM   EMPLOYEE 
GROUP BY DEPT_ID 
ORDER BY 2 ;

SELECT *
FROM   EMPLOYEE ;

SELECT JOB_ID,
       ROUND(AVG(SALARY))
FROM   EMPLOYEE 
GROUP BY JOB_ID 
ORDER BY 2 ;

SELECT 
       DECODE(SUBSTR(EMP_NO, 8,1),'1','남자','3','남자','여자') AS 성별,
       ROUND(AVG(SALARY)) 
FROM   EMPLOYEE
GROUP BY DECODE(SUBSTR(EMP_NO, 8,1),'1','남자','3','남자','여자') ;

---- 그룹소계값 나오게하는 함수 ROLLUP
--ex) GROUP BY ROLLUP(DEPT_ID, EMP_NAME)
SELECT DEPT_ID,
       EMP_NAME,
       COUNT(*)
FROM  EMPLOYEE
GROUP BY ROLLUP(DEPT_ID, EMP_NAME) ;

--WHERE는 (셀렉)테이블에 대한 조건, HAVING은 그룹에 대한 조건(WHERE절에서는 집계함수 사용 불가함)
SELECT DEPT_ID, SUM(SALARY)
FROM   EMPLOYEE
GROUP BY DEPT_ID
HAVING SUM(SALARY) > 9000000 ;

SELECT DEPT_ID, SUM(SALARY)
FROM   EMPLOYEE
WHERE  SUM(SALARY) > 9000000
GROUP BY DEPT_ID ;


SELECT *
FROM   EMPLOYEE ;

SELECT EMP_NAME,
       DEPT_NAME
FROM   EMPLOYEE E, DEPARTMENT D
WHERE  E.DEPT_ID = D.DEPT_ID ;
--Equals 조인,DEPT_ID가 두군데 있어서 애매모호함

SELECT EMP_NAME,
       DEPT_NAME
FROM   EMPLOYEE E
JOIN   DEPARTMENT D USING(DEPT_ID) ;
--ANSI 표준, 두테이블 간에 기본키와 외래키 관계를 맺고있어도 칼럼값이 다르면 ON으로 사용가능

SELECT DEPT_NAME,
       LOC_DESCRIBE
FROM   LOCATION L
JOIN   DEPARTMENT D ON(LOCATION_ID = LOC_ID) ;


SELECT EMP_NAME,
       SALARY,
       SLEVEL
FROM   EMPLOYEE E, SAL_GRADE S
WHERE  SALARY BETWEEN LOWEST AND HIGHEST ;
--NOT Equals 조인, 샐러리가 LOWEST와 HIGHEST 사이에 있다

SELECT EMP_NAME,
       SALARY,
       SLEVEL,
       JOB_TITLE
FROM   EMPLOYEE E, SAL_GRADE S, JOB J
WHERE  SALARY BETWEEN LOWEST AND HIGHEST 
AND    E.JOB_ID = J.JOB_ID ;

SELECT EMP_NAME,
       SALARY,
       SLEVEL,
       JOB_TITLE,
       DEPT_NAME
FROM   EMPLOYEE E, SAL_GRADE S, JOB J, DEPARTMENT D
WHERE  SALARY BETWEEN LOWEST AND HIGHEST 
AND    E.JOB_ID = J.JOB_ID 
AND    E.DEPT_ID = D.DEPT_ID ;

SELECT EMP_NAME,
       SALARY,
       SLEVEL
FROM   EMPLOYEE E
JOIN   SAL_GRADE S ON(SALARY BETWEEN LOWEST AND HIGHEST) ;

SELECT *
FROM   EMPLOYEE ;

SELECT *
FROM   DEPARTMENT ;

SELECT EMP_NAME,
       DEPT_NAME,
       D.DEPT_ID
FROM   DEPARTMENT D, EMPLOYEE E
WHERE  D.DEPT_ID = E.DEPT_ID(+) ;
