CREATE TABLE TEST
(ID   NUMBER(5),
 NAME CHAR(10),
 ADDRESS VARCHAR2(50)
 ) ;
 
SELECT *
FROM   TEST ;

CREATE TABLE TABLE_NOTNULL
(ID  CHAR(3) NOT NULL,
 SNAME VARCHAR2(20)) ;
 
INSERT INTO TABLE_NOTNULL
VALUES ('100', 'ORACLE') ;
INSERT INTO TABLE_NOTNULL
VALUES (NULL,'ORACLE') ;

--제약이 없으면 관계형 데이터베이스에서 중복된 데이터가 많이 나올수 있음
CREATE TABLE TABLE_NOTNULL2
 (ID   CHAR(3)
  SNAME VARCHAR2(20),
  CONSTRAINT TN2_ID_NN NOT NULL (ID)) ;
  
--DDL
--CREATE TABLE
--Pascal case : StudentEntity (클래스를 만들때 많이씀)
--Came case : numberOfGrade (함수정의할때 많이씀)
--Snake case : service_member_tbl (변수정의할때 많이씀)

DROP TABLE StudentEntity ;

CREATE TABLE StudentEntity(
   SSN   VARCHAR2(50), 
   NAME  VARCHAR2(20), 
   GENDER CHAR(1),
   ADDRESS VARCHAR2(50),
   JOB   VARCHAR2 (100),
   PRIMARY KEY(SSN, NAME)
  );
--컴퍼짓 프라이머리(개별 컬럼에서 프라이머리 키 2개설정안될때 적용)


INSERT INTO StudentEntity
VALUES ('830910-1xxxxxx', '섭섭해', 'M', 'SEOUL', 'INSTRUCTOR') ;

INSERT INTO StudentEntity
VALUES ('830910-2xxxxxx', '임섭순', 'M', 'SEOUL', 'INSTRUCTOR') ;

--기본키가 없으면 관계형 데이터를 만들수 없음
--UNIQUE+NOT NULL = PRIMARY KEY
--REFERENCE TABLE에 의해 부모키에 의지하는 외래키의 값은 NULL값 허용
--NOT_NULL은 테이블레벨 설정에 제약을 거는 형태는 안됨


CREATE TABLE StudentEntitysub(
     PHONE   VARCHAR2(13) PRIMARY KEY,
     MAJOR   VARCHAR2(50),
     SSN     VARCHAR2(50),
     NAME   VARCHAR2(20),
     FOREIGN KEY (SSN, NAME) REFERENCES StudentEntity(SSN, NAME) );
--컴퍼짓 프라이머리키가 같이 넘어올수 있기때문에 컬럼레벨로 REFERENCE 안됨
    
SELECT *
FROM   StudentEntity ;
    
INSERT INTO StudentEntitysub
VALUES ('010-0000-0000', '경영학과', '900000-0000000', '김아무개') ;
--넣고자하는 테이블의 외래키가 부모키에 정의된 데이터값(SSN, NAME)이 없거나 NULL값이 아니기 때문에 에러

INSERT INTO StudentEntitysub
VALUES ('010-0000-0000', '경영학과', NULL, NULL) ;

SELECT *
FROM   StudentEntitysub ;




CREATE TABLE TABLE_FK
(ID   CHAR(3),
 SNAME VARCHAR2(20),
 LID   CHAR(2) REFERENCES LOCATION (LOCATION_ID));

INSERT INTO TABLE_FK
VALUES ('200', 'ORACLE', 'A1');

INSERT INTO TABLE_FK
VALUES ('100', 'ORACLE', NULL) ;

INSERT INTO TABLE_FK
VALUES (NULL, 'ORACLE', 'U1') ;

SELECT *
FROM   TABLE_FK ;

CREATE TABLE TABLE_FK2
(ID    CHAR(10),
 SNAME VARCHAR2(20),
 GENDER VARCHAR2(5));

INSERT INTO TABLE_FK2
VALUES ('100', 'ORACLE', 'U1') ;


SELECT *
FROM   TABLE_FK2 ;

SELECT *
FROM   TABLE_FK
JOIN   TABLE_FK2 USING(ID) ;


DROP TABLE TABLE_FK3 ;

CREATE TABLE TABLE_FK3
(ID CHAR(3),
 SNAME VARCHAR2(20),
 LID CHAR(2),
 FOREIGN KEY(LID)REFERENCE LOCATION(LOCATION_ID)) ;
 

CREATE TABLE StudentEntity(
   SSN   VARCHAR2(50) PRIMARY KEY,
   NAME  VARCHAR2(20) NOT NULL,
   GENDER CHAR(1),
   ADDRESS VARCHAR2(50),
   JOB   VARCHAR2 (100)
  );

INSERT INTO StudentEntity
VALUES ('830910-1xxxxxx', '섭섭해', 'M', 'SEOUL', 'INSTRUCTOR') ;

INSERT INTO StudentEntity
VALUES ('830910-1xxxxxx', '섭섭해', 'M', 'SEOUL', 'INSTRUCTOR') ;  
--중복x 
INSERT INTO StudentEntity
VALUES (NULL, '섭섭해', 'M', 'SEOUL', 'INSTRUCTOR') ;   
--NULL값 허용X  
INSERT INTO StudentEntity(NAME, GENDER, ADDRESS, JOB)
VALUES ('섭섭해', 'M', 'SEOUL', 'INSTRUCTOR') ;     
--묵시적으로 NULL값으로 인식

INSERT INTO StudentEntity
VALUES ('830910-1xxxxxx', '섭섭해', 'MALE', 'SEOUL', 'INSTRUCTOR') ;
--사이즈에 맞지않음

SELECT *
FROM   StudentEntity ;
  

DROP TABLE StudentEntity ;
--부모키와 자식간에 관계를 맺고있을때는 부모키에 해당하는 테이블 드랍이 되지않음?? 이럴떄는 제약으로 참조컬럼값이 삭제될때 포린키 컬럼값도 같이 삭제하도록 할 수 있지만 이용주의해야함

CREATE TABLE TABLE_CHECK
(EMP_ID    CHAR(3) PRIMARY KEY,
 SALARY    NUMBER CHECK (SALARY >0),
 MARRIAGE  CHAR(1),
 CONSTRAINT CHK_MRG CHECK(MARRIAGE IN ('Y', 'N')) ) ;

INSERT INTO TABLE_CHECK
VALUES ('100', -100, 'Y') ;

INSERT INTO TABLE_CHECK
VALUES ('100', 500, '?') ;

CREATE TABLE STUDENT(
     STU_ID NUMBER PRIMARY KEY) ;

CREATE TABLE SUBJECT(
     SJT_ID NUMBER PRIMARY KEY) ;

CREATE TABLE ENROLL(
     STU_ID NUMBER,
     SJT_ID NUMBER,               
     PRIMARY KEY(STU_ID, SJT_ID),
     FOREIGN KEY(STU_ID) REFERENCES STUDENT(STU_ID),
     FOREIGN KEY(SJT_ID) REFERENCES SUBJECT(SJT_ID)
) ;
    
CREATE TABLE ENROLL(
     STU_ID NUMBER REFERENCES STUDENT(STU_ID),
     SJT_ID NUMBER REFERENCES SUBJECT(SJT_ID),               
     PRIMARY KEY(STU_ID, SJT_ID),
) ;


CREATE TABLE TABLE_SUBQUERY2 (EID, ENAME, SALARY, DNAME, JTITLE)
AS SELECT EMP_ID, EMP_NAME, SALARY, DEPT_NAME, JOB_TITLE
   FROM EMPLOYEE
   LEFT JOIN DEPARTMENT USING(DEPT_ID)
   LEFT JOIN JOB USING(JOB_ID) ;

SELECT *
FROM   TABLE_SUBQUERY2 ;

--주로 서브쿼리 중 뷰는 읽기전용으로 많이 사용
--단일테이블로 만들어진 뷰는 조작가능하지만 멀티테이블로 만들어진 뷰는 조작불가능
CREATE OR REPLACE VIEW V_EMP
AS SELECT EMP_NAME, DEPT_ID
   FROM   EMPLOYEE
   WHERE  DEPT_ID = '90' ;
   
SELECT *
FROM   V_EMP ;

SELECT COLUMN_NAME, DATA_TYPE, NULLABLE
FROM   USER_TAB_COLS
WHERE  TABLE_NAME = 'V_EMP' ;

CREATE OR REPLACE VIEW V_EMP_DEPT_JOB
AS SELECT EMP_NAME,
          DEPT_NAME,
          JOB_TITLE
FROM  EMPLOYEE
LEFT JOIN DEPARTMENT USING(DEPT_ID)
LEFT JOIN JOB USING(JOB_ID)
WHERE JOB_TITLE = '사원' ;

CREATE OR REPLACE VIEW V_EMP (ENAME,Gender,WORKYEAR)
AS SELECT EMP_NAME,
          DECODE(SUBSTR(EMP_NO, 8,1),'1','남자','3','남자','여자'),
          ROUND(MONTHS_BETWEEN(SYSDATE, HIRE_DATE)/12, 0)
FROM  EMPLOYEE ;

CREATE OR REPLACE VIEW V_DEPT_SALAVG("Did", "Davg")
AS SELECT NVL(DEPT_ID, 'N/A'),
          ROUND(AVG(SALARY),-3)
FROM      EMPLOYEE
GROUP BY  DEPT_ID ;

SELECT EMP_NAME, SALARY
FROM   EMPLOYEE
JOIN   V_DEPT_SALAVG ON(NVL(DEPT_ID, 'N/A') = "Did")
WHERE  SALARY > "Davg"
ORDER BY 2 DESC ;

SELECT ROWNUM, EMP_NAME, SALARY
FROM  (SELECT NVL(DEPT_ID,'N/A')AS "Did",
              ROUND(AVG(SALARY),-3) AS "Davg"
       FROM  EMPLOYEE
       GROUP BY DEPT_ID) INLV
JOIN  EMPLOYEE ON(NVL(DEPT_ID, 'N/A') = INLV."Did")
WHERE SALARY > INLV."Davg"
ORDER BY 3 DESC ;
---SALARY를 기준으로 내림차순하니까 로우넘이 섞임

SELECT ROWNUM, EMP_NAME, SALARY
FROM  (SELECT NVL(DEPT_ID,'N/A')AS "Did",
              ROUND(AVG(SALARY),-3) AS "Davg"
       FROM  EMPLOYEE
       GROUP BY DEPT_ID) INLV
JOIN  EMPLOYEE ON(NVL(DEPT_ID, 'N/A') = INLV."Did")
WHERE SALARY > INLV."Davg" 
AND   ROWNUM <= 5;
---로우넘은 이퀄 몇자리 숫자던지 최상위만 가져오고 2등,3등 못가져옴, 대신 범위는 가능한데 먼저 정렬순서를 서브쿼리로 정리하고 로우넘을 부여해야함  ex)TOP5

SELECT ROWNUM, EMP_NAME, SALARY
FROM  (SELECT EMP_NAME, SALARY
       FROM  (SELECT NVL(DEPT_ID,'N/A')AS "Did",
                     ROUND(AVG(SALARY),-3) AS "Davg"
              FROM  EMPLOYEE
              GROUP BY DEPT_ID) INLV
       JOIN  EMPLOYEE ON(NVL(DEPT_ID, 'N/A') = INLV."Did")
       WHERE SALARY > INLV."Davg"
       ORDER BY 2 DESC)
WHERE   ROWNUM <= 5;

CREATE SEQUENCE TEST_SEQ ;
-- NEXTVAL
-- CURRVAL

SELECT TEST_SEQ.NEXTVAL
FROM  DUAL ;

SELECT TEST_SEQ.CURRVAL
FROM   DUAL ;






--DML (데이터 조작어)
--INSERT
INSERT INTO 테이블명([컬럼지정, 컬럼, ....])
VALUES (값, 값, .....) ;